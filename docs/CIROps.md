<!-- Autogenerated by mlir-tblgen; don't manually edit -->
### `cir.alloca` (::mlir::cir::AllocaOp)

local variable


Syntax:

```
operation ::= `cir.alloca` $type `,` `cir.ptr` type($addr) `,` `[` $name `,` $init `]` attr-dict
```

The `cir.alloca` operation defines a local variable.

Possible initialization styles are: uninitialized, paraminit,
callinit, cinit and listinit.

The result is a pointer type for the original input type.

Example:

```mlir
// Local variable with uninitialized value.
// int count = ...
%0 = cir.alloca i32, !cir.ptr<i32>, ["count", cinit]
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `type` | ::mlir::TypeAttr | any type attribute
| `name` | ::mlir::StringAttr | string attribute
| `init` | ::mlir::cir::InitStyleAttr | variable initialization style
| `alignment` | ::mlir::IntegerAttr | 64-bit signless integer attribute whose minimum value is 0

#### Results:

| Result | Description |
| :----: | ----------- |
| `addr` | CIR pointer type

### `cir.binop` (::mlir::cir::BinOp)

binary operations (arith and logic)


Syntax:

```
operation ::= `cir.binop` `(` $kind `,` $lhs `,` $rhs  `)` `:` type($lhs) attr-dict
```

"cir.binop performs the binary operation according to
 the specified kind/opcode: [mul, div, rem, add, sub, shl,
 shr, and, xor, or]. It accepts to input operands and the
 result type must match both types.

 Example
 ```
 %7 = binop(add, %1, %2) : i32
 %7 = binop(mul, %1, %2) : i8
 ```

Traits: SameOperandsAndResultType, SameTypeOperands

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `kind` | ::mlir::cir::BinOpKindAttr | binary operation (arith and logic) kind

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `cir.brcond` (::mlir::cir::BrCondOp)

conditional branch operation


Syntax:

```
operation ::= `cir.brcond` $cond
              $destTrue (`(` $destOperandsTrue^ `:` type($destOperandsTrue) `)`)?
              `,`
              $destFalse (`(` $destOperandsFalse^ `:` type($destOperandsFalse) `)`)?
              attr-dict
```

The `cir.brcond %cond, ^bb0, ^bb1` branches to 'bb0' block in case
%cond (which must be a !cir.bool type) evaluates to true, otherwise
it branches to 'bb1'.

Example:

```mlir
  ...
    cir.brcond %a, ^bb3, ^bb4
  ^bb3:
    cir.return
  ^bb4:
    cir.yield
```

Traits: SameVariadicOperandSize, Terminator

Interfaces: BranchOpInterface, NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `cond` | CIR bool type
| `destOperandsTrue` | any type
| `destOperandsFalse` | any type

#### Successors:

| Successor | Description |
| :-------: | ----------- |
| `destTrue` | any successor
| `destFalse` | any successor

### `cir.br` (::mlir::cir::BrOp)

branch operation


Syntax:

```
operation ::= `cir.br` $dest (`(` $destOperands^ `:` type($destOperands) `)`)? attr-dict
```

The `cir.br` branches unconditionally to a block.

Example:

```mlir
  ...
    cir.br ^bb3
  ^bb3:  // pred: ^bb2
    cir.return
```

Traits: Terminator

Interfaces: BranchOpInterface, NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `destOperands` | any type

#### Successors:

| Successor | Description |
| :-------: | ----------- |
| `dest` | any successor

### `cir.cast` (::mlir::cir::CastOp)

cast


Syntax:

```
operation ::= `cir.cast` `(` $kind `,` $src `:` type($src) `)`
              `,` type($result) attr-dict
```

Apply C/C++ usual conversions rules between types. The full list of those
can be seen in clang/include/clang/AST/OperationKinds.def, but note that some
of the conversions aren't implemented in terms of cir.cast, lvalue-to-rvalue
for instance is modeled as a load.

```mlir
%4 = cir.cast (int_to_bool, %3 : i32), !cir.bool
...
%x = cir.cast(array_to_ptrdecay, %0 : !cir.ptr<!cir.array<i32 x 10>>), !cir.ptr<i32>
```

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `kind` | ::mlir::cir::CastKindAttr | cast kind

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `cir.cmp` (::mlir::cir::CmpOp)

compare operation


Syntax:

```
operation ::= `cir.cmp` `(` $kind `,` $lhs `,` $rhs  `)` `:` type($lhs) `,` type($result) attr-dict
```

"cir.cmp compares two input operands and produces a bool result. The input
 operands must have the same type. The kinds of comparison available are:
 [lt,gt,ge,eq,ne]

 Example
 ```
 %7 = cir.cmp(gt, %1, %2) : i32, !cir.bool
 ```

Traits: SameTypeOperands

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `kind` | ::mlir::cir::CmpOpKindAttr | compare operation kind

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `cir.cst` (::mlir::cir::ConstantOp)

constant operation


Syntax:

```
operation ::= `cir.cst` `(` custom<ConstantValue>($value) `)` attr-dict `:` type($res)
```

Constant operation turns a literal into an SSA value. The data is attached
to the operation as an attribute. For example:

```mlir
  %0 = cir.cst(42 : i32) : i32
  %1 = cir.cst(4.2 : f32) : f32
  %2 = cir.cst(nullptr : !cir.ptr<i32>) : !cir.ptr<i32>
```

Traits: ConstantLike

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `value` | ::mlir::Attribute | any attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | any type

### `cir.get_global` (::mlir::cir::GetGlobalOp)

get the memref pointing to a global variable


Syntax:

```
operation ::= `cir.get_global` $name `:` `cir.ptr` type($addr) attr-dict
```

The `cir.get_global` operation retrieves the address pointing to a
named global variable. If the global variable is marked constant, writing
to the resulting address (such as through a `cir.store` operation) is
undefined. Resulting type must always be a !cir.ptr<...> type.

Example:

```mlir
%x = cir.get_global @foo : !cir.ptr<i32>
```

Interfaces: NoSideEffect (MemoryEffectOpInterface), SymbolUserOpInterface

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `addr` | CIR pointer type

### `cir.global` (::mlir::cir::GlobalOp)

declare or define a global variable


Syntax:

```
operation ::= `cir.global` ($sym_visibility^)?
              (`constant` $constant^)?
              $sym_name
              custom<GlobalOpTypeAndInitialValue>($sym_type, $initial_value)
              attr-dict
```

The `cir.global` operation declares or defines a named global variable.

The backing memory for the variable is allocated statically and is
described by the type of the variable.

The operation is a declaration if no `inital_value` is
specified, else it is a definition.

The global variable can also be marked constant using the
`constant` unit attribute. Writing to such constant global variables is
undefined.

Example:

```mlir
// Externally available and constant variable with initial value.
cir.global public constant @c : i32 = 4;
```

Interfaces: Symbol

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sym_name` | ::mlir::StringAttr | string attribute
| `sym_visibility` | ::mlir::StringAttr | string attribute
| `sym_type` | ::mlir::TypeAttr | any type attribute
| `initial_value` | ::mlir::Attribute | any attribute
| `constant` | ::mlir::UnitAttr | unit attribute
| `alignment` | ::mlir::IntegerAttr | 64-bit signless integer attribute

### `cir.if` (::mlir::cir::IfOp)

if-then-else operation

The `cir.if` operation represents an if-then-else construct for
conditionally executing two regions of code. The operand to an if operation
is a boolean value.

Each region can contain an arbitrary number of blocks but there usually be
only one block in each region unless the presence of return and goto.

Examples:

```mlir
cir.if %b  {
  ...
} else {
  ...
}

cir.if %c  {
  ...
}

cir.if %c  {
  ...
  br ^a
^a:
  cir.yield
}
```

`cir.if` defines no values and the 'else' can be omitted. `cir.yield` must
explicitly terminate the region if it has more than one block.

Traits: AutomaticAllocationScope, NoRegionArguments, RecursiveSideEffects

Interfaces: RegionBranchOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `condition` | CIR bool type

### `cir.load` (::mlir::cir::LoadOp)

load operation


Syntax:

```
operation ::= `cir.load` (`deref` $isDeref^)? $addr `:` `cir.ptr` type($addr) `,`
              type($result) attr-dict
```

`cir.load` reads a variable (lvalue to rvalue conversion) given an address
backed up by a `cir.ptr` type.

Example:

```mlir

// Read from local variable, address in %0.
%1 = cir.load %0 : !cir.ptr<i32>, i32

// Load address from memory at address %0. %3 provides
// the address used while dereferecing a pointer.
%3 = cir.load deref %0 : cir.ptr <!cir.ptr<i32>>
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `isDeref` | ::mlir::UnitAttr | unit attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `addr` | CIR pointer type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `cir.loop` (::mlir::cir::LoopOp)

loop operation


Syntax:

```
operation ::= `cir.loop` $kind
              `(`
              `cond` `:` $cond `,`
              `step` `:` $step
              `)`
              $body
              attr-dict
```


Traits: NoRegionArguments, RecursiveSideEffects

Interfaces: LoopLikeOpInterface, RegionBranchOpInterface

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `kind` | ::mlir::cir::LoopOpKindAttr | Loop kind

### `cir.ptr_stride` (::mlir::cir::PtrStrideOp)

pointer access with stride


Syntax:

```
operation ::= `cir.ptr_stride` `(` $base `:` type($base) `,` $stride `:` type($stride) `)`
              `,` type($result) attr-dict
```

Given a base pointer as operand, provides a new pointer after applying
a stride. Used for array subscripts, vectors, etc.

```mlir
%3 = cir.cst(0 : i32) : i32
%4 = cir.ptr_stride(%2 : !cir.ptr<i32>, %3 : i32), !cir.ptr<i32>
```

Traits: SameFirstOperandAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `base` | any type
| `stride` | integer

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `cir.return` (::mlir::cir::ReturnOp)

return operation


Syntax:

```
operation ::= `cir.return` ($input^ `:` type($input))? attr-dict
```

The "return" operation represents a return operation within a function.
The operation takes an optional operand and produces no results.
The operand type must match the signature of the function that contains
the operation. For example:

```mlir
  func @foo() -> AnyType {
    ...
    cir.return %0 : AnyType
  }
```

Traits: HasParent<FuncOp, ScopeOp, IfOp, SwitchOp, LoopOp>, Terminator

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `input` | any type

### `cir.scope` (::mlir::cir::ScopeOp)



"cir.scope" contains one region and defines a strict "scope" for all new
values produced within its blocks.

The region can contain an arbitrary number of blocks but should usually be
only one block if return and goto are not present.

"cir.yield" is required as a terminator and can have results, in which case
it can be omitted. Not used anywhere just yet but might be used to explicitly
model lifetime extension.

Traits: AutomaticAllocationScope, NoRegionArguments, RecursiveSideEffects

Interfaces: RegionBranchOpInterface

#### Results:

| Result | Description |
| :----: | ----------- |
| `results` | any type

### `cir.store` (::mlir::cir::StoreOp)

store operation


Syntax:

```
operation ::= `cir.store` $value `,` $addr attr-dict `:` type($value) `,` `cir.ptr` type($addr)
```

`cir.load` reads a variable using a pointer type.

Example:

```mlir

// Store to local variable, address in %0.
cir.store %arg0, %0 : i32, !cir.ptr<i32>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `value` | any type
| `addr` | CIR pointer type

### `cir.struct_element_addr` (::mlir::cir::StructElementAddr)

get the address of a member of a struct

The `cir.struct_element_addr` operaration gets the address of a particular
named member from the input struct.

Example:
```mlir
!22struct2EBar22 = type !cir.struct<"struct.Bar", i32, i8>
...
%0 = cir.alloca !22struct2EBar22, cir.ptr <!22struct2EBar22>
...
%1 = cir.struct_element_addr %0, "Bar.a"
%2 = cir.load %1 : cir.ptr <int>, int
WIP
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `member_name` | ::mlir::StringAttr | string attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `struct_addr` | CIR pointer type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | CIR pointer type

### `cir.switch` (::mlir::cir::SwitchOp)

a switch operation


Syntax:

```
operation ::= `cir.switch` custom<SwitchOp>(
              $regions, $cases, $condition, type($condition)
              )
              attr-dict
```

The `cir.switch` operation represents C/C++ switch functionality for
conditionally executing multiple regions of code. The operand to an switch
is an integral condition value.

A variadic list of "case" attribute operands and regions track the possible
control flow within `cir.switch`. Each "case" first operand could be:
- "equal": equality check against the condition.
- "anyof": equals to any of the values in a following list.
- "default": any other value.

An optional second operand denotes the actual value (or list of).
Types value(s) should match the condition and among themselves (in the list
case).

Each case region must be explicitly terminated with a cir.yield operation.

Examples:

```mlir
cir.switch (%b : i32) [
  case (equal, 20) {
    ...
    cir.yield break
  },
  case (anyof, [1, 2, 3] : i32) {
    ...
    cir.return ...
  }
  case (default) {
    ...
    cir.yield fallthrough
  }
]
```

Traits: AutomaticAllocationScope, NoRegionArguments, RecursiveSideEffects, SameVariadicOperandSize

Interfaces: RegionBranchOpInterface

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `cases` | ::mlir::ArrayAttr | cir.switch case array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `condition` | integer

### `cir.yield` (::mlir::cir::YieldOp)

termination operation for regions inside if, for, scope, etc


Syntax:

```
operation ::= `cir.yield` ($kind^)? ($args^ `:` type($args))? attr-dict
```

"cir.yield" yields an SSA value from a CIR dialect op region and
terminates the regions. The semantics of how the values are yielded is
defined by the parent operation.

Currently, there are not parents where `cir.yield` has any operands,
but it will be useful to represent lifetime extension in the future.

When used to leave `cir.switch` regions there are two possible meanings:
1. `cir.yield break` has "breaking out of the outermost" switch semantics.
2. `cir.yield fallthrough` means the next region in the case list should
be executed.

`cir.yield loopcondition %val` is another form that must terminate cond
regions within `cir.loop`s.

The `cir.yield` must be explicitly used whenever a region has more than
one block, or within `cir.switch` regions not `cir.return` terminated.

Example:
```
cir.if %4 {
  ...
  cir.yield
}

cir.switch (%5) [
  case (equal, 3) {
    ...
    cir.yield fallthrough
  }, ...
]

cir.loop (cond : {...}, step : {...}) {
  ...
  cir.yield continue
}
```

Traits: HasParent<IfOp, ScopeOp, SwitchOp, LoopOp>, ReturnLike, Terminator

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `kind` | ::mlir::cir::YieldOpKindAttr | yield kind

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `args` | any type

